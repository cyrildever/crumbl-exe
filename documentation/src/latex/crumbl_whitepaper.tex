% FEISTEL white paper

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside,twocolumn]{article}

\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{eufrak}
\usepackage{graphicx} % For \scalebox

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\arabic{subsection}} % roman numerals only for subsections
\titleformat{\section}[block]{\Large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large\scshape}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Crumbled Data Storage $\bullet$ Cyril Dever} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text
\setlength{\headheight}{14pt}

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage[symbol]{footmisc} % To use special character in footnote
\renewcommand{\thefootnote}{\arabic{footnote}}

\usepackage{outlines}
\usepackage[font=itshape]{quoting}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\SetKw{Continue}{continue}
\SetKw{KwBy}{by}

%----------------------------------------------------------------------------------------
%	FUNCTIONS
%----------------------------------------------------------------------------------------

\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\bsfnote}{\textsuperscript{*}} % for reference to the base64 string note
\newcommand{\hexnote}{\textsuperscript{$\dagger$}} % for reference to the hex string note
\newcommand{\mod}[1]{\ \mathrm{mod}\ #1}

%----------------------------------------------------------------------------------------
%	LISTINGS
%----------------------------------------------------------------------------------------

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem*{remark}{Note}
\newtheorem*{recall}{Recall}

%----------------------------------------------------------------------------------------
%	FIGURES
%----------------------------------------------------------------------------------------

\usepackage{tikz}
\usepackage{caption}

\usetikzlibrary{shapes.geometric, arrows, calc, positioning}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, text width=1.7cm, inner sep=0.4cm, draw=black]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, inner sep=-0.1cm, draw=black]
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{XOR/.style={draw,circle,append after command={
        [shorten >=\pgflinewidth, shorten <=\pgflinewidth,]
        (\tikzlastnode.north) edge (\tikzlastnode.south)
        (\tikzlastnode.east) edge (\tikzlastnode.west)
        }
    }
}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\usepackage[english]{datetime2}
\DTMsavedate{thedate}{2020-09-18}

\setlength{\droptitle}{-5\baselineskip} % Move the title up

\pretitle{\begin{center}\Large\bfseries}
\posttitle{\end{center}}
\title{Data Storage By Secure Crumbling \\With Signing Trusted Third Parties} % Title
\author{%
    \textsc{Cyril Dever}\\ % Name
    \normalsize Edgewhere \\ % Institution
}
% \date{\today} % Leave empty to omit a date
\date{\DTMusedate{thedate}}
\renewcommand{\maketitlehookd}{%
    \begin{abstract}
        \noindent We define a secure data storage solution based on the presence of one (or more) trusted third parties necessary to perform encryption 
        and decryption operations on a message split in crumbs. This secure storage method is particularly safe since the encryption elements are 
        distributed among the different participants and can't be discovered by a single procedure which would allow breaking a unique encryption code. 
        We show that this distribution of crumbs and their separate encryption considerably increases the security of the storage since, in the absence 
        of a participant, the message can't be recovered. Furthermore, the algorithm doesn't allow anyone other than the rightful owner of the original 
        message to know in clear all or part of the data at any time whatsoever. This technique is pending patent\footnotemark.
    \end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

{\renewcommand{\thefootnote}{\fnsymbol{footnote}} \footnotetext[1]{filed under registration number \texttt{FR1908258} at INPI on July 19, 2019}}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}

\lettrine[nindent=0em,lines=3]{T}here are already multiple available ways to store data after encrypting it. However, the current techniques of data 
encryption for the storage and recovery of stored data and their decryption are operations all the more complex as the security must be high.

This complexity comes with the added burden of the risk that the encryption key is always susceptible to being broken and/or hacked.

The goal of our new algorithm, called the \texttt{crumbl}\textregistered~technology, is to develop simple yet particularly effective means for securing 
data storage.

Our procedure describes a method of secure storage of a source data, owned by one (or more) \emph{holder(s)}, using already proven techniques of 
asymmetric encryption with the participation of so-called trusted third parties, each having a pair of private and public keys.

%----------------------------------------------------------------------------------------

\section{Basic Definitions}

\begin{definition}[Source Data]
    \label{sourceData}
    The source data $d$ is the data that has to be protected by the \texttt{crumbl} encryption protocol.
\end{definition}

\begin{definition}[Crumbl]
    \label{crumbl}
    A \emph{crumbl} (or crumbled string) is the final result of the encryption of a source data through the \texttt{crumbl} process.
    Among other elements, it uses crumbs which come from slices of the source data.
\end{definition}

\begin{definition}[Crumb]
    \label{crumb}
    A crumb $\varsigma$ is an encrypted portion of data of size $n$ in its binary form:
    \begin{equation}
        \label{eq:crumb}
        \varsigma := \sum_{j=0}^{n-1} x_j \mid x_j \in \{ 0, 1 \}
    \end{equation}
    It could be the byte array itself or any string representation of it (hexadecimal, binary, base-64, \dots).

    When presented with a lower index (eg. $\varsigma_8$), it indicates the order (starting at $0$) in which to eventually concatenate it with the 
    others. With an added upper index (eg. $\varsigma^\pi)$, it indicates its signer ($\pi$) during encryption.

    A set of crumbs can only be assigned to one source data. In other words, it is obvious that one can't mix a crumb $c1$ from a data $d1$ with a 
    crumb $c2$ from a data $d2$.
\end{definition}

\begin{definition}[Slice]
    \label{slice}
    A slice $\sigma$ is a padded plaintext portion of the source data.

    Let $\mu()$ be a padding function and $\mu^{-1}()$ its inverse. For $t$ slices made out of a source data $d$, we have:
    \begin{small}
        \begin{equation}
            \label{eq:slice}
            \left\{
                \begin{array}{l}
                    \sigma_i := \mu \Big[ \left( \frac{d}{t} \right)_i \Big] \\ \\
                    d := \mu^{-1}(\sigma_0) \mathbin\Vert \mu^{-1}(\sigma_1) \mathbin\Vert \dots \mathbin\Vert \mu^{-1}(\sigma_{t-1}) \\
                \end{array}
            \right.
        \end{equation}
    \end{small}
\end{definition}

%----------------------------------------------------------------------------------------

\section{The Protocol}

\begin{definition}[Operation]
    An operation takes a source data and encrypts it with the \texttt{crumbl}, or back.
\end{definition}

\begin{definition}[Participant]
    \label{participant}
    A participant $\pi \in P$ (or signer) is defined by his pair of public ($PK$) and private ($SK$) keys unique to an \texttt{crumbl} operation 
    he is taking part along with other participants/signers.

    \begin{equation}
        \label{eq:participant}
        \begin{array}{rl}
            \pi: P &\to (\mathcal{K} \times \mathcal{K}) \\
                \pi_i &\mapsto (\pi_i^{SK}, \pi_i^{PK}) \\
        \end{array}
    \end{equation}

    There are two kinds of participants involved in the process:
    \begin{itemize}
        \item The holders who wish to protect their asset, ie. the source data;
        \item The trusted third parties, generally being corporations and the main sponsors of the system, who only participate in data 
            encryption/decryption as signers and are paid for it.
    \end{itemize}
\end{definition}

\begin{definition}[Holder]
    The holder is the only participant able to have access to the data in clear, ie. the source data.
    He could be the rightful owner of the data or anyone to whom the latter delegates its use.

    He is (or they are, should there be more than one holder involved in an operation) the signer(s) of a special crumb: $\varsigma_0$, ie. the one 
    with index $0$.
\end{definition}

There must be at least one holder and one trusted third party in the list of participants\footnote{We shall see that maximum security starts with at 
least four participants: one holder and three trusted third parties.}.

\subsection{Encryption}

Algorithm \ref{algo:encryption} presents the encryption protocol of the \texttt{crumbl}\textregistered~technology.

\vspace{1em} % one line separation

Let $p$ be the number of participants forming the set $P \gets \{ \pi_p\}$ of signers, $P_0 \in P$ the subset of holders, and $P_\tau \in P$ the subset 
of trusted third parties with $P_0 \cup P_\tau = P$.

And let $H$ be the holder of the source data $d$.

Finally, let $\mathfrak{c}()$ be the encryption function of the \texttt{crumbl}\footnote{It could be any asymmetric protocol as long as it is available 
for $H$. Thus, we assume that $H$ knows beforehand which protocol uses each participant $\pi_i$; therefore, he'd be using the appropriate 
$\mathfrak{c}_{\pi_i}()$ function.}:
\begin{equation}
    \label{eq:encrypt}
    \begin{array}{rl}
        \mathfrak{c}: \qquad \quad \omega \times \mathcal{K} &\to \omega \\
                (msg, pubkey) &\mapsto \mathfrak{c}(msg, pubkey) \\
    \end{array}
\end{equation}
\begin{algorithm}
    \SetKwProg{throw}{throw}{}{}
    \KwIn{$d$, $P$}
    \KwOut{$Cr$}
    \If{$|d| = 0 \vee |P| < 2$}{
        \throw{error}{}
    }
    initialize a new set of crumbs: $\mathcal{C} \gets \emptyset$; \\
    ask all participants $\pi_i \in P \setminus {\pi_H}$ for their new public key; \\
    each participant $\pi_i$ creates a new pair of keys along with a request ID $\pi_i^{RID}$, this tuple being stored for future use in the decryption 
        process; \\
    $d$ is prepared and split into a set of $t$ slices $\{ \sigma_0, \dots, \sigma_{t-1} \}$ with: $t = |P_\tau| + 1$; \\
    $H$ encrypts $\sigma_0$ with his own new public key: $$
        \mathcal{C} \gets \varsigma_0^{\pi_H} := \mathfrak{c}_{\pi_H}(\sigma_0, \pi_H^{PK})
    $$ \\
    \While{$H$ receives each participant's public key ($\pi_i^{PK}$)}{
        \eIf{$\pi_i \in P_0$}{
            $H$ encrypts $\sigma_0$: $$
                \mathcal{C} \gets \varsigma_0^{\pi_{i}} := \mathfrak{c}_{\pi_i}(\sigma_0, \pi_i^{PK})
            $$ \\
        }{
            all other slices are encrypted by $H$ with the received public key: $$
            \begin{array}{l}
                \forall j \in \{ \sigma_1, \dots, \sigma_{t-1} \}: \\
                \quad \mathcal{C} \gets \varsigma_j^{\pi_{i}} := \mathfrak{c}_{\pi_i}(\sigma_j, \pi_i^{PK})
            \end{array}
            $$ \\
        }
    }
    $Cr$ is finalized by $H$ using $d$ and the set of all crumbs $\mathcal{C}$; \\
    \Return{$Cr$}
    \caption{Encryption protocol}
    \label{algo:encryption}
\end{algorithm}

As shown, everything takes place in $H$ environment which guarantees that the source data is never sent, let alone known, by any other stakeholder.

If no error is raised, the output crumbl $Cr$ can be stored anywhere, by any of the stakeholders and/or some outsourcer (eg. a hosting service). In any 
case, $H$ should store a tuple of references to $Cr$ (or $d$) and the keypair used for the operation. He may also store its verification hash and use 
it for that purpose.

\begin{definition}[Verification Hash]
    \label{verificationHash}
    A verification hash $V$ is made of the concatenation of the 32 first characters of a crumbled string $Cr$:
    \begin{equation}
        \label{eq:verificationHash}
        V := \mathbin\Vert_{i=1}^{32} Cr[i]
    \end{equation}
    where $Cr[i]$ is the $i$-th character of $Cr$.

    The verification hash is unique to an operation \textemdash~see Definition \ref{hashered}.

    It is generally used for search or storage purposes. For example, our latest implementation requires that we ask a hosting service for a crumbl by 
    sending its verification hash.

    By definition, it is verified that\footnote{We will use this notation in the rest of the document when we want to assert that a passed $V$ is $Cr$'s 
    appropriate verification hash.}: $V \subset Cr$.
\end{definition}

\subsection{Decryption}

Algorithm \ref{algo:decryption} presents the decryption protocol.

\vspace{1em} % one line separation

Let $P'_\tau$ a subset of $P_\tau$ of size $1 \leq n \leq |P_\tau| - 1$, and $H_1$ one of the signing holders that wishes to recover the data.

And let $HR()$ be the hashered function \textemdash~see (\ref{eq:hashered}).

Finally, let $\mathfrak{D}()$ be the decryption function of the \texttt{crumbl}:
\begin{equation}
    \label{eq:decrypt}
    \begin{array}{rl}
        \mathfrak{D}: \quad \mathbb{N} \times \omega \times \mathcal{K} &\to \omega \\
                (j, Cr, privkey) &\mapsto \mathfrak{D}(j, Cr, privkey) \\
    \end{array}
\end{equation}
with $j$ being the $j$-th crumb in $Cr$.

\begin{algorithm}
    \SetKwProg{throw}{throw}{}{}
    \KwIn{$Cr$, a decrypter $\pi_{H_1} \in P_0$, $P'_\tau$, an optional $V$}
    \KwOut{$d$}
    \uIf{$V \neq \emptyset \wedge V \not\subset Cr$}{
        \throw{error}{}
    }\uElseIf{$V = \emptyset$}{
        $V \gets \mathbin\Vert_{i=1}^{32}(Cr)$; \\ 
    }
    initialize a new set of slices $S \gets \emptyset$; \\
    from $Cr$, we set the number of needed slices $t$; \\
    % initialize a new set of crumbs: $\mathcal{C} \gets \{ \varsigma_{\pi_n} \mid \pi_n \in P_0 \cup P'_\tau \}$; \\
    \For{$i \gets 0$ \KwTo $p = |P'_\tau| - 1$ \KwBy $1$}{
        $H1$ requests his decrypted crumbs to trusted third party $\pi_i$; \\
    }
    \ForEach{participant $\pi_i$}{
        initialize $j \gets 1$; \\
        \Repeat{$j = t$}{
            \If{$\exists \sigma_j := \mathfrak{D}(j, Cr, \pi_i^{SK})$}{
                $\pi_i$ sends his slice $\sigma_j$; \\
            }
            $j \gets j + 1$; \\
        }
    }
    \While{$|S| \neq t$ \emph{AND} \\\qquad $H1$ receives new slice $\sigma_j$}{
        \If{$\sigma_j \not\in S$}{
            $S \gets \sigma_j$; \\
        }
    }
    $H1$ decrypts his own crumb: $S \gets \mathfrak{D}(0, Cr, \pi_{H1}^{SK})$; \\
    use (\ref{eq:slice}) to recover $d$:$$
        d \gets \mu^{-1}(\sigma_0) \mathbin\Vert \mu^{-1}(\sigma_1) \mathbin\Vert \dots \mathbin\Vert \mu^{-1}(\sigma_{t-1})
    $$ \\
    \If{$HR(d) \neq V$}{
        \throw{error}{}
    }
    \Return{$d$}
    \caption{Decryption protocol}
    \label{algo:decryption}
\end{algorithm}

\vspace{1em} % one line separation // TODO Get rid of it?

Lorem ipsum ... % // TODO

\begin{definition}[Hashered Prefix]
    \label{hashered}
    Lorem ipsum ... % // TODO
    \begin{equation}
        \label{eq:hashered}
        HR: % // TODO
    \end{equation}
\end{definition}

%\vfill\eject % To force break column if need be
% \tableofcontents % Uncomment to add a table of contents

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

% \begin{thebibliography}{99} % Bibliography
%
% \bibitem[1]{feistel:hf}
% Horst Feistel. \emph{Cryptography and Computer Privacy}, Scientific American, 1973.
%
% \end{thebibliography}

%----------------------------------------------------------------------------------------

\end{document}