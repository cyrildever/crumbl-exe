% FEISTEL white paper

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside,twocolumn]{article}

\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{eufrak}
\usepackage{graphicx} % For \scalebox

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\arabic{subsection}} % roman numerals only for subsections
\titleformat{\section}[block]{\Large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large\scshape}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Crumbled Data Storage $\bullet$ Cyril Dever} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text
\setlength{\headheight}{14pt}

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage[symbol]{footmisc} % To use special character in footnote
\renewcommand{\thefootnote}{\arabic{footnote}}

\usepackage{outlines}
\usepackage[font=itshape]{quoting}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\SetKw{Continue}{continue}
\SetKw{KwBy}{by}

%----------------------------------------------------------------------------------------
%	FUNCTIONS
%----------------------------------------------------------------------------------------

\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\bsfnote}{\textsuperscript{*}} % for reference to the base64 string note
\newcommand{\hexnote}{\textsuperscript{$\dagger$}} % for reference to the hex string note
\newcommand{\mod}[1]{\ \mathrm{mod}\ #1}

%----------------------------------------------------------------------------------------
%	LISTINGS
%----------------------------------------------------------------------------------------

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem*{remark}{Note}
\newtheorem*{recall}{Recall}

%----------------------------------------------------------------------------------------
%	FIGURES
%----------------------------------------------------------------------------------------

\usepackage{tikz}
\usepackage{caption}

\usetikzlibrary{shapes.geometric, arrows, calc, positioning}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, text width=1.7cm, inner sep=0.4cm, draw=black]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, inner sep=-0.1cm, draw=black]
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzset{XOR/.style={draw,circle,append after command={
        [shorten >=\pgflinewidth, shorten <=\pgflinewidth,]
        (\tikzlastnode.north) edge (\tikzlastnode.south)
        (\tikzlastnode.east) edge (\tikzlastnode.west)
        }
    }
}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\usepackage[english]{datetime2}
\DTMsavedate{thedate}{2020-09-18}

\setlength{\droptitle}{-5\baselineskip} % Move the title up

\pretitle{\begin{center}\Large\bfseries}
\posttitle{\end{center}}
\title{Data Storage By Secure Crumbling \\With Signing Trusted Third Parties} % Title
\author{%
    \textsc{Cyril Dever}\\ % Name
    \normalsize Edgewhere \\ % Institution
}
% \date{\today} % Leave empty to omit a date
\date{\DTMusedate{thedate}}
\renewcommand{\maketitlehookd}{%
    \begin{abstract}
        \noindent We define a secure data storage solution based on the presence of one (or more) trusted third parties necessary to perform encryption 
        and decryption operations on a message split in crumbs. This secure storage method is particularly safe since the encryption elements are 
        distributed among the different participants and can't be discovered by a single procedure which would allow breaking a unique encryption code. 
        We show that this distribution of crumbs and their separate encryption considerably increases the security of the storage since, in the absence 
        of a participant, the message can't be recovered. Furthermore, the algorithm doesn't allow anyone other than the rightful owner of the original 
        message to know in clear all or part of the data at any time whatsoever. This technique is pending patent\footnotemark.
    \end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

{\renewcommand{\thefootnote}{\fnsymbol{footnote}} \footnotetext[1]{filed under registration number \texttt{FR1908258} at INPI on July 19, 2019}}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}

\lettrine[nindent=0em,lines=3]{T}here are already multiple available ways to store data after encrypting it. However, the current techniques of data 
encryption for the storage and recovery of stored data and their decryption are operations all the more complex as the security must be high.

This complexity comes with the added burden of the risk that the encryption key is always susceptible to being broken and/or hacked.

The goal of our new algorithm, called the \texttt{crumbl}\textregistered~technology, is to develop simple yet particularly effective means for securing 
data storage.

Our procedure describes a method of secure storage of a source data, owned by one (or more) \emph{holder(s)}, using already proven techniques of 
asymmetric encryption with the participation of so-called trusted third parties, each having a pair of private and public keys.

%----------------------------------------------------------------------------------------

\section{Basic Definitions}

\begin{definition}[Source Data]
    \label{sourceData}
    The source data $d$ is the data that has to be protected by the \texttt{crumbl} encryption protocol.
\end{definition}

\begin{definition}[Crumbl]
    \label{crumbl}
    A \emph{crumbl} (or crumbled string) is the final result of the encryption of a source data through the \texttt{crumbl} process.
    Among other elements, it uses crumbs which come from slices of the source data.
\end{definition}

\begin{definition}[Crumb]
    \label{crumb}
    A crumb $\varsigma$ is an encrypted portion of data of size $n$ in its binary form:
    \begin{equation}
        \label{eq:crumb}
        \varsigma := \sum_{j=0}^{n-1} x_j \mid x_j \in \{ 0, 1 \}
    \end{equation}
    It could be the byte array itself or any string representation of it (hexadecimal, binary, base-64, \dots).

    When presented with a lower index (eg. $\varsigma_8$), it indicates the order (starting at $0$) in which to eventually concatenate it with the 
    others. With an added upper index (eg. $\varsigma^\pi)$, it indicates its signer ($\pi$) during encryption.

    A set of crumbs can only be assigned to one source data. In other words, it is obvious that one can't mix a crumb $c1$ from a data $d1$ with a 
    crumb $c2$ from a data $d2$.
\end{definition}

\begin{definition}[Slice]
    \label{slice}
    A slice $\sigma$ is a padded plaintext portion of the source data.

    Let $\mu()$ be a padding function and $\mu^{-1}()$ its inverse. For $t$ slices made out of a source data $d$, we have:
    \begin{small}
        \begin{equation}
            \label{eq:slice}
            \left\{
                \begin{array}{l}
                    \sigma_i := \mu \Big[ \left( \frac{d}{t} \right)_i \Big] \\ \\
                    d := \mu^{-1}(\sigma_0) \mathbin\Vert \mu^{-1}(\sigma_1) \mathbin\Vert \dots \mathbin\Vert \mu^{-1}(\sigma_{t-1}) \\
                \end{array}
            \right.
        \end{equation}
    \end{small}
\end{definition}

%----------------------------------------------------------------------------------------

\section{The Protocol}

\begin{definition}[Operation]
    An operation takes a source data and encrypts it with the \texttt{crumbl}, or back.
\end{definition}

\begin{definition}[Participant]
    \label{participant}
    A participant $\pi \in P$ (or signer) is defined by his pair of public ($PK$) and private ($SK$) keys unique to an \texttt{crumbl} operation 
    he is taking part along with other participants/signers.

    \begin{equation}
        \label{eq:participant}
        \begin{array}{rl}
            \pi: P &\to (\mathcal{K} \times \mathcal{K}) \\
                \pi_i &\mapsto (\pi_i^{SK}, \pi_i^{PK}) \\
        \end{array}
    \end{equation}

    There are two kinds of participants involved in the process:
    \begin{itemize}
        \item The holders who wish to protect their asset, ie. the source data;
        \item The trusted third parties, generally being corporations and the main sponsors of the system, who only participate in data 
            encryption/decryption as signers and are paid for it.
    \end{itemize}
\end{definition}

\begin{definition}[Holder]
    The holder is the only participant able to have access to the data in clear, ie. the source data.
    He could be the rightful owner of the data or anyone to whom the latter delegates its use.

    He is (or they are, should there be more than one holder involved in an operation) the signer(s) of a special crumb: $\varsigma_0$, ie. the one 
    with index $0$.
\end{definition}

There must be at least one holder and one trusted third party in the list of participants\footnote{We shall see that maximum security starts with at 
least four participants: one holder and three trusted third parties.}.

\subsection{Encryption}

Algorithm \ref{algo:encryption} presents the encryption protocol of the \texttt{crumbl}\textregistered~technology.

\vspace{1em} % one line separation

Let $p$ be the number of participants forming the set $P \gets \{ \pi_p\}$ of signers, $P_0 \in P$ the subset of holders, and $P_\tau \in P$ the subset 
of trusted third parties with $P_0 \cup P_\tau = P$.

And let $H$ be the holder of the source data $d$.

Finally, let $\mathfrak{c}()$ be the encryption function of the \texttt{crumbl}\footnote{It could be any asymmetric protocol as long as it is available 
for $H$ in the \emph{words} space $\omega$. Thus, we assume that $H$ knows which protocol uses each participant $\pi_i$; therefore, he'd be using the 
appropriate $\mathfrak{c}_{\pi_i}()$ function.}:
\begin{equation}
    \label{eq:encrypt}
    \begin{array}{rl}
        \mathfrak{c}: \qquad \quad \omega \times \mathcal{K} &\to \omega \\
                (msg, pubkey) &\mapsto \mathfrak{c}(msg, pubkey) \\
    \end{array}
\end{equation}
\begin{algorithm}
    \SetKwProg{throw}{throw}{}{}
    \KwIn{$d$, $P$}
    \KwOut{the crumbled string $Cr$ or an error}
    \If{$|d| = 0 \vee |P| < 2$}{
        \throw{invalid input}{}
    }
    initialize a new set of crumbs: $\mathcal{C} \gets \emptyset$; \\
    ask all participants $\pi_i \in P \setminus {\pi_H}$ for their new public key; \\
    each participant $\pi_i$ creates a new pair of keys along with a request ID $\pi_i^{RID}$, this tuple being stored for future use in the decryption 
        process; \\
    $d$ is prepared and split into a set of $t$ slices $\{ \sigma_0, \dots, \sigma_{t-1} \}$ with: $t = |P_\tau| + 1$; \\
    $H$ encrypts $\sigma_0$ with his own new public key:
    \begin{equation}
        \label{eq:crumb0}
        \mathcal{C} \gets \varsigma_0^{\pi_H} := \mathfrak{c}_{\pi_H}(\sigma_0, \pi_H^{PK})
    \end{equation} \\
    \While{$H$ receives each participant's public key ($\pi_i^{PK}$)}{
        \eIf{$\pi_i \in P_0$}{
            $H$ encrypts $\sigma_0$: $$
                \mathcal{C} \gets \varsigma_0^{\pi_{i}} := \mathfrak{c}_{\pi_i}(\sigma_0, \pi_i^{PK})
            $$ \\
        }{
            all other slices are encrypted by $H$ with the received public key: $$
            \begin{array}{l}
                \forall j \in \{ \sigma_1, \dots, \sigma_{t-1} \}: \\
                \quad \mathcal{C} \gets \varsigma_j^{\pi_{i}} := \mathfrak{c}_{\pi_i}(\sigma_j, \pi_i^{PK})
            \end{array}
            $$ \\
        }
    }
    $Cr$ is finalized by $H$ using $d$ and the set of all crumbs $\mathcal{C}$; \\
    \Return{$Cr$}
    \caption{Encryption protocol}
    \label{algo:encryption}
\end{algorithm}

As shown, everything takes place in $H$ environment which guarantees that the source data is never sent, let alone known, by any other stakeholder.

If no error is raised, the output crumbl $Cr$ can be stored anywhere, by any of the stakeholders and/or some outsourcer (eg. a hosting service). In any 
case, $H$ should store a tuple of references to $Cr$ (or $d$) and the keypair used for the operation. He may also store its verification hash and use 
it for that purpose.

\begin{definition}[Verification Hash]
    \label{verificationHash}
    A verification hash $V$ is made of the concatenation of the 64 first characters of a crumbled string $Cr$:
    \begin{equation}
        \label{eq:verificationHash}
        V := \mathbin\Vert_{i=1}^{64} Cr[i]
    \end{equation}
    where $Cr[i]$ is the $i$-th character of $Cr$.

    By design, the verification hash is unique to an operation \textemdash~see Definition \ref{hashered} and (\ref{eq:hashered}).

    It is generally used for search or storage purposes\footnote{For example, our latest implementation requires that we ask a hosting service for a 
    crumbl by sending its verification hash.}.

    By definition, it is verified that\footnote{We will use the notation $V \subset Cr$ in the rest of the document when we want to assert that a 
    passed $V$ is $Cr$'s appropriate verification hash.}: $V \subset Cr$.
\end{definition}

\subsection{Decryption}

Algorithm \ref{algo:decryption} presents the decryption protocol.

\vspace{1em} % one line separation

Let $P'_\tau$ a subset of $P_\tau$ of size $1 \leq n \leq |P_\tau| - 1$, and $H_1$ one of the signing holders that wishes to recover the data.

And let $\upsilon(d)$ be the hashered function to build a verification hash for a data $d$ \textemdash~see (\ref{eq:hashered}), and 
\texttt{MIN\_LENGTH} $ > 64$ the minimum required length of a crumbled string.

Finally, let $\mathfrak{D}()$ be the decryption function of the \texttt{crumbl}:
\begin{equation}
    \label{eq:decrypt}
    \begin{array}{rl}
        \mathfrak{D}: \quad \mathbb{N} \times \omega \times \mathcal{K} &\to \omega \\
                (j, Cr, privkey) &\mapsto \mathfrak{D}(j, Cr, privkey) \\
    \end{array}
\end{equation}
with $j$ being the $j$-th crumb.

\begin{algorithm}
    \SetKwProg{throw}{throw}{}{}
    \KwIn{$Cr$, a decrypter $H_1 \in P_0$, $P'_\tau$, an optional verification hash $V$}
    \KwOut{the data $d$ or an error}
    \uIf{$V \neq \emptyset \wedge V \not\subset Cr$}{
        \throw{invalid verification hash}{}
    }\uElseIf{$|Cr| < $ \emph{\texttt{MIN\_LENGTH}}}{
        \throw{invalid crumbled string}{}
    }
    from $Cr$, get the number $t$ of slices; \\
    initialize a new set of slices $\mathcal{S} \gets \emptyset$; \\
    set the timeout limit $\theta$; \\
    initialize $R$ the map of received messages by $H1$ with cardinality $t$: $\forall i \in [1..t]: R_i \gets \emptyset$; \\
    \For{$i \gets 1$ \KwTo $p$ \KwBy $1$}{
        $H_1$ requests his decrypted crumbs to trusted third party $\pi_i$; \\
    }
    \While{current time $\leq \theta$}{
        \ForEach{$\pi_i \in P'_\tau$}{
            \For{$j \gets 1$ \KwTo $t$ \KwBy $1$}{
                \If{$\exists \sigma_j := \mathfrak{D}(j, Cr, \pi_i^{SK})$}{
                    $\pi_i$ sends his slice $\sigma_j$ to $H1$: $R_{j,i} \gets \sigma_j^{\pi_i}$; \\
                }
            }
        }
    }
    \For{$j \gets 1$ \KwTo $|R|$ \KwBy $1$}{
        process received $\sigma_j^{\pi_i}$: $\sigma_j \gets \sigma_j^{\pi_i}$; \\
        \If{$\sigma_j \not\in \mathcal{S}$}{
            $\mathcal{S} \gets \sigma_j$; \\
        }
    }
    \If{$|\mathcal{S}| \neq t$}{
        \throw{missing ($t - |\mathcal{S}|$) slices}{}
    }
    $H_1$ decrypts crumb $0$:
    \eIf{$\exists \sigma_0 := \mathfrak{D}(0, Cr, {H_1}^{SK})$} {
        $S \gets \sigma_0$
    }{
        \throw{$H_1$ is not a holder}{}
    }
    use (\ref{eq:slice}) on $\mathcal{S} := \{ \sigma_t \}$ to recover $d$:$$
        d \gets \mu^{-1}(\sigma_0) \mathbin\Vert \mu^{-1}(\sigma_1) \mathbin\Vert \dots \mathbin\Vert \mu^{-1}(\sigma_{t-1})
    $$ \\
    \If{$V \neq \emptyset \wedge \upsilon(d) \neq V$}{
        \throw{invalid recovered data $d$ against verification hash $V$}{}
    }
    \Return{$d$}
    \caption{Decryption protocol}
    \label{algo:decryption}
\end{algorithm}

\vspace{1em} % one line separation

If there's no error, the returned item is a copy of the original source data as a string.

%----------------------------------------------------------------------------------------

\section{The Process}

This section describes the detailed encryption process used in the $\mathfrak{c}()$ and $\mathcal{D}()$ functions in the above protocol.

\begin{definition}[Crumbled string]
    \label{crumbledString}
    The final crumbled string $Cr$ is made of the concatenation of a so-called hashered prefix with the base-64 string representation of all the crumbs:
    \begin{equation}
        \label{eq:crumbledString}
        Cr := \upsilon(d) \mathbin\Vert \left( \sum_{i=0}^t \sum_{j=0}^p (\varsigma_i^{\pi_j})_{64} \right)
    \end{equation}
    where we use the symbol $\sum$ in the end part of (\ref{eq:crumbledString}) for concatenation\footnote{From now on, we may use this notation 
    whenever it's clear in the explanation, or the $\sum^{\mathbin\Vert}$ alternative when applied on a full set/array.}.
\end{definition}

\subsection{A unique prefix}

Let $sort(items)$ be the function that returns a lexicographically sorted set of items\footnote{
    If the items are presented as a map, they are first lexicographically sorted on their keys, then their values are also lexicographically sorted.
}, and $cut(word, at)$ the function that splits the passed $word$ in two after the $at$-th character.

And let $\mathfrak{h}()$ be a secure cryptographic hashing function returning a 256-bits hash\footnote{We use the \texttt{SHA-256} algorithm in our 
implementation because of its native availability in most browsers.}.

\begin{definition}[Hashered prefix]
    \label{hashered}
    We build the hashered prefix by concatenating two parts:
    \begin{itemize}
        \item The 32 first characters of the hexadecimal string representation of the hash of the source data (using $\mathfrak{h}()$): $h^+$;
        \item The 32 last characters of this hash ($h^-$) XORed with the padded lexicographically sorted owners' crumbs concatenation in hexadecimal.
    \end{itemize}
    \begin{equation}
        \label{eq:hashAndSplit}
        \Rightarrow h^+, h^- := cut \left( \mathfrak{h}(d), 32 \right)
    \end{equation}

    \vspace{1em} % one line separation

    Let $HR()$ be the hashering function that takes $h^-$ and the set of crumbs $\mathcal{C}$, and returns the second part of the hashered prefix.
    \begin{equation}
        \label{eq:hashering}
        \begin{array}{rl}
            HR: \omega \times \omega^t &\to \omega \\
                (h^-, \mathcal{C}) &\mapsto h^- \oplus \left( \sum^{\mathbin\Vert} sort(\mathcal{C}) \right)
        \end{array} 
    \end{equation}

    The full hashering function $\upsilon()$ takes the source data $d$ and its associated set of crumbs to return the hashered prefix using 
    (\ref{eq:hashAndSplit}) in the process to build $h^+$ and $h^-$:
    \begin{equation}
        \label{eq:hashered}
        \begin{array}{rl}
            \upsilon: \quad \omega \times \omega^t &\to \omega \\
                (d, \mathcal{C}) &\mapsto \upsilon(d, \mathcal{C}) := h^+ \mathbin\Vert HR(h^-, \mathcal{C}) \\
        \end{array}
    \end{equation}

    The use of the hashering function ($HR()$) ensures the hashered prefix uniqueness.

    \begin{proof}
        Let $d$ be a source data owned by $\pi_{h}$, and $Cr_1$ and $Cr_2$ the results of the \texttt{crumbl} process from two operations $O_1$ and 
        $O_2$ (respectively initiated by $\pi_{h_{O_1}}$ and $\pi_{h_{O_2}}$).

        We are trying to prove that, for $O_1$ and $O_2$, their respective crumbled string ($Cr^{O_1}$ and $Cr^{O_2}$) will be different as long as at 
        least $\pi_{h}$ respects the process (even if some or all other participants don't play fair).

        Thanks to Definition \ref{participant}, we know that $\pi_h$ would use different keypairs for $O_1$ and $0_2$ such as:$$
            \varsigma_0^{\pi_{h_{O_1}}} \neq \varsigma_0^{\pi_{h_{O_2}}}
        $$

        Because (\ref{eq:hashering}) uses $sort()$, we known that $\varsigma_0$ will always be the first crumb used to build the hashered prefix.
        
        Therefore, through (\ref{eq:hashered}), let $x_1$ and $x_2$ be the hashered prefixes during $O_1$ and $O_2$, we have:$$
        \begin{array}{l}
            \left\{
                \begin{array}{ll}
                    x_1 \gets \upsilon(d, \mathcal{C}_1) &\iff \mathcal{C}_1 := \{ \varsigma_0^{\pi_{h_{O_1}}}, \dots \} \\
                    x_2 \gets \upsilon(d, \mathcal{C}_2) &\iff \mathcal{C}_2 := \{ \varsigma_0^{\pi_{h_{O_2}}}, \dots \} \\
                \end{array}
            \right. \\ \\
            \quad \Rightarrow x_1 \neq x_2 \\
            \end{array}
        $$
        
        With (\ref{eq:crumbledString}), we can conclude that:$$
            \forall \pi_h, d: \textrm{if } \pi_{h_{O_1}} \neq \pi_{h_{O_2}} \textrm{ then } Cr^{O_1} \neq Cr^{O_2}
        $$
    \end{proof}
\end{definition}

Prepended to the crumbs, this prefix gives the crumbled string absolute uniqueness, in particular between two different operations on the same source 
data.

Furthermore, it allows easy indexing.

\subsection{Crumb and uncrumb}

Lorem ipsum ... % // TODO

%\vfill\eject % To force break column if need be
% \tableofcontents % Uncomment to add a table of contents

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

% \begin{thebibliography}{99} % Bibliography
%
% \bibitem[1]{feistel:hf}
% Horst Feistel. \emph{Cryptography and Computer Privacy}, Scientific American, 1973.
%
% \end{thebibliography}

%----------------------------------------------------------------------------------------

\end{document}